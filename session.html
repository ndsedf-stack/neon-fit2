<!DOCTYPE html>
<html lang="fr" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>SESSION // COCKPIT TACTIQUE</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: { cyan: '#22d3ee', fuchsia: '#c084fc' },
          animation: { 'pulse': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite' }
        }
      }
    }
  </script>
  
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700;800&family=Inter:wght@400;500;600;800&display=swap" rel="stylesheet">
  
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "lucide-react": "https://esm.sh/lucide-react@0.300.0"
    }
  }
  </script>
  
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="program-data-v2.js"></script>
  
  <style>
    :root { --cyan: #22d3ee; --magenta: #c084fc; --bg: #000000; }
    html, body, #root { height: 100%; height: 100dvh; margin: 0; padding: 0; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; color: white; }
    .font-hud { font-family: 'Rajdhani', sans-serif; }
  </style>
</head>

<body>
  <div id="root"></div>
  
  <script type="text/babel" data-type="module">
    import React, { useEffect, useState, useRef } from 'react';
    import { createRoot } from 'react-dom/client';
    import { ArrowDown, ArrowUp, Zap, Target, User, Plus, Minus, AlertTriangle, Wind, Timer, SkipForward } from 'lucide-react';

    // URL params
    const urlParams = new URLSearchParams(window.location.search);
    const weekNum = parseInt(urlParams.get('week')) || 1;
    const dayKey = urlParams.get('day') || 'dimanche';
    
    const programData = window.programData;
    let workoutData = null;
    let weekData = null;
    
    try {
      weekData = programData.getWeek(weekNum);
      workoutData = programData.getWorkout(weekNum, dayKey);
    } catch(e) {
      console.error('Error:', e);
    }

    // ========================================
    // ACTIVE SERIES MODULE
    // ========================================
    const ActiveSeriesModule = ({ exercise, currentSetIndex, totalSets, targetReps, load, tempo, restTime, onComplete, onAbort }) => {
      const [currentLoad, setCurrentLoad] = useState(load);
      const [currentTargetReps, setCurrentTargetReps] = useState(targetReps);
      const [currentSet, setCurrentSet] = useState(currentSetIndex);
      const [repsRemaining, setRepsRemaining] = useState(targetReps);
      const [phase, setPhase] = useState('ecc');
      const [phaseProgress, setPhaseProgress] = useState(0);
      const [isSetFinished, setIsSetFinished] = useState(false);
      const [totalTUT, setTotalTUT] = useState(0);
      const [sessionVolume, setSessionVolume] = useState(0);
      const [isResting, setIsResting] = useState(false);
      const [restTimeRemaining, setRestTimeRemaining] = useState(0);
      const [breathPhase, setBreathPhase] = useState('in');
      const [breathProgress, setBreathProgress] = useState(0);
      const [abortProgress, setAbortProgress] = useState(0);
      const abortIntervalRef = useRef(null);

      const { ecc, iso, con } = tempo;

      useEffect(() => {
        setCurrentLoad(load);
        setCurrentTargetReps(targetReps);
        setRepsRemaining(targetReps);
        setCurrentSet(currentSetIndex);
        setIsSetFinished(false);
        setPhase('ecc');
        setPhaseProgress(0);
        setTotalTUT(0);
      }, [load, targetReps, currentSetIndex]);

      // TEMPO ENGINE
      useEffect(() => {
        if (isResting || isSetFinished) return;
        const totalRepDuration = (ecc + iso + con) * 1000;
        const eccDuration = ecc * 1000;
        const isoDuration = iso * 1000;
        
        const interval = setInterval(() => {
          setTotalTUT(prev => prev + 0.05);
          setPhaseProgress((prev) => {
            const next = prev + 50;
            if (next < eccDuration) {
              if (phase !== 'ecc') setPhase('ecc');
              return next;
            } else if (next < eccDuration + isoDuration) {
              if (phase !== 'iso') setPhase('iso');
              return next;
            } else if (next < totalRepDuration) {
              if (phase !== 'con') setPhase('con');
              return next;
            } else {
              setRepsRemaining((r) => {
                if (r - 1 <= 0) { setIsSetFinished(true); return 0; }
                return r - 1;
              });
              return 0;
            }
          });
        }, 50);
        return () => clearInterval(interval);
      }, [ecc, iso, con, isResting, isSetFinished, phase]);

      // REST TIMER
      useEffect(() => {
        if (!isResting) return;
        if (restTimeRemaining <= 0) { skipRest(); return; }
        const timer = setInterval(() => setRestTimeRemaining(prev => prev - 1), 1000);
        return () => clearInterval(timer);
      }, [isResting, restTimeRemaining]);

      // BREATHING
      useEffect(() => {
        if (!isResting) return;
        const interval = setInterval(() => {
          setBreathProgress(prev => {
            const next = prev + 50;
            const pos = next % 16000;
            if (pos < 4000) setBreathPhase('in');
            else if (pos < 8000) setBreathPhase('hold');
            else if (pos < 12000) setBreathPhase('out');
            else setBreathPhase('hold');
            return next;
          });
        }, 50);
        return () => clearInterval(interval);
      }, [isResting]);

      const getPhasePercentage = (p) => {
        const eccDur = ecc * 1000, isoDur = iso * 1000;
        if (isSetFinished) return p === 'con' ? 100 : 0;
        if (phase !== p) return 0;
        if (phase === 'ecc') return (phaseProgress / eccDur) * 100;
        if (phase === 'iso') return ((phaseProgress - eccDur) / isoDur) * 100;
        return ((phaseProgress - eccDur - isoDur) / (con * 1000)) * 100;
      };

      const handleValidate = () => {
        setIsSetFinished(true);
        setSessionVolume(prev => prev + currentLoad * currentTargetReps);
        setTimeout(() => startRest(), 500);
      };

      const startRest = () => {
        setIsResting(true);
        setRestTimeRemaining(restTime);
        setBreathProgress(0);
      };

      const skipRest = () => {
        setIsResting(false);
        if (currentSet >= totalSets) {
          onComplete && onComplete();
        } else {
          setCurrentSet(prev => prev + 1);
          setRepsRemaining(currentTargetReps);
          setIsSetFinished(false);
          setPhase('ecc');
          setPhaseProgress(0);
          setTotalTUT(0);
        }
      };

      const handleAbortStart = () => {
        setAbortProgress(0);
        abortIntervalRef.current = setInterval(() => {
          setAbortProgress(prev => {
            if (prev >= 100) {
              clearInterval(abortIntervalRef.current);
              onAbort && onAbort();
              return 100;
            }
            return prev + 5;
          });
        }, 50);
      };

      const handleAbortEnd = () => {
        if (abortIntervalRef.current) clearInterval(abortIntervalRef.current);
        setAbortProgress(0);
      };

      // REST OVERLAY
      if (isResting) {
        const mins = Math.floor(restTimeRemaining / 60);
        const secs = restTimeRemaining % 60;
        return (
          <div className="fixed inset-0 bg-black/98 backdrop-blur-xl flex flex-col items-center justify-center p-6 z-50">
            <div className="absolute